{"name":"Webrockit.github.io","tagline":"WebRockit Documentation","body":"### Welcome to the Github pages for WebRockit\r\nWebRockit uses a headless web browser to measure how fast web pages load, relative to what a real user might experience. WebRockit also captures interesting metrics about the page load (time to first byte, number of assets, size of response, etc) and can draw some time-series graphs using that data. WebRockit is intended for periodic collection of this data, but is not intended to stress test a web host. WebRockit combines the scalability of <a href=\"http://sensuapp.org/\" target=\"_blank\">Sensu</a>, the accessibility of <a href=\"http://graphite.wikidot.com/\" target=\"_blank\">Graphite</a>, backed by the reliability of <a href=\"http://qt-project.org/doc/qt-5.0/qtwebkit/qtwebkit-index.html\" target=\"_blank\">WebKit</a>. WebRockit is designed for a web-ops audience, but is a useful toolkit for the entire spectrum of web professionals.  WebRockit will run on Fedora >=19 and Centos=>6.0, with future support for Debian, Ubuntu, and other popular Linux distributions.  \r\n\r\nWebRockit comes with instructions on how to bring up new Graphite and Sensu server components, but may also fit in with existing Graphite and Sensu services you are already running.  WebRockit aims to provide all necessary services where all the services are geographically local to each other, but may function when communicating with geo-remote services (YMMV).  \r\n\r\n\r\nWebRockit exposes a REST API so url checks can be added/changed/removed through automation. We follow the <a href=\"https://github.com/godaddy/gdapi/blob/master/specification.md\" target=\"_blank\">GD API</a> specification. The WebRockit UI uses the API to handle all aspects of the human visualiation and administration interface. WebRockit also includes a component to apply checks to Sensu and restart Sensu services where necessary, using the WebRockit API. WebRockit is able to poll sites which do not have active public DNS or where you wish to override the standard DNS resolution for a host.  \r\n\r\nWebRockit is able to poll at least 500 unique URLs every 5 minutes where each URL is less than 1.5MB in size, from a single polling server (with 1GB ram, 1x 1.8Ghz quad core Xeon). It can operate at much higher volumes than this, but this gives at least some idea on expectations when sizing server real-estate.  Spinning up 2 virtual instances with most c-word providers (one for sensu/graphite/ui server, one for the poller client), with about 1GB of ram each, will be enough to query and measure several hundred URLs.\r\n![WebRockit Infrastructure](images/webrockit_infrastructure.thumb.png)  \r\n\r\nWhile it is technically possible to mash this toolkit into other purposes (OpenStack service monitoring you say? Go on..), we don't encourage it (yet). This toolkit has one main job, and that's to measure how webpages load over time in a browser.  Franken-steining this into other tasks might work -- but we would caution: understand what problems you are trying to solve first, before you end up building a bridge to Mars. So far, we haven't found a great open source solution to address our challenges, so that's why we did this.  \r\n\r\nIf you add network-diversity to where the polls are made from, you can get a bit of triangulation. While that's nifty and potentially useful (West Coast vs East Coast perspective?), one important thing this suite doesn't do yet is tie activity to performance. One cannot rely solely on this data to make business decisions.  You must understand what activity is leading to your performance state. This can mean diving into answering questions such as:\r\n\r\n* Is my cpu a bottleneck? Are my cores %100 busy for my poorly threaded application?\r\n* Are my requests periodically being served from a cold cache or hitting a cache's max TTL? (DNS, opcode, inode, dentry, TCP metrics, DB query cache, and so on)\r\n* Am I hitting a network resource limitation? (Saturated link, asynchronous route through a lossy channel, etc)\r\n* And more!  \r\n\r\nWe hope to eventually include concurrent activity data point collection for folks that control their own infrastructure, so that bottlenecks can be identified and alarms can be raised -- but that is further down in our list of goals. Even in that space, correlation is not always causation can hold true (but as we've found, not always).","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}